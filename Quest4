// Exercise 1
func IterativeFactorial(nb int) int {
	// If nb is 0, return 1
	if nb == 0 {
		return 1
	} else if nb < 0 || nb > 64 {
		// If nb is negative or greater than 64, return 0
		return 0
	} else {
		// Initialize the result variable to 1
		result := 1
		// Loop to calculate the factorial
		for i := 1; i <= nb; i++ {
			result *= i
		}
		// Return the final result
		return result
	}
}
-----------------------------------------------------------------------------------------------------------------------
// Exercise 2
package main

import "fmt"

// RecursiveFactorial is a recursive function that calculates the factorial of the number nb.
// If nb is negative or greater than 64, it returns 0.
func RecursiveFactorial(nb int) int {
	// If nb is 0, return 1
	if nb == 0 {
		return 1
	} else if nb < 0 || nb > 64 {
		// If nb is negative or greater than 64, return 0
		return 0
	} else {
		// Return nb multiplied by RecursiveFactorial with decremented nb
		return nb * RecursiveFactorial(nb-1)
	}
}

func main() {
	arg := -8
	// Call RecursiveFactorial with nb=-8 and print the result
	fmt.Println(RecursiveFactorial(arg))
}
------------------------------------------------------------------------------------------------------------------------
// Exercise 3 - Question 4

// IterativePower is an iterative function that returns the value of nb to the power of power.
// Negative powers will return 0. Overflows do not have to be dealt with.
func IterativePower(nb int, power int) int {
	// Check for negative power
	if power < 0 {
		return 0
	}

	// Initialize the result variable to 1
	result := 1

	// Iterate from 1 to power and multiply nb by itself
	for i := 1; i <= power; i++ {
		result *= nb
	}

	// Return the final result
	return result
}
-------------------------------------------------------------------------------------------------------------------------
// Exercise 4 - Question 4
package main

import "fmt"

// IterativePower is a recursive function that calculates the value of nb raised to the power of power.
// If power is negative, the result will be 0. If power is 0, the result will be 1.
// Overflows do not have to be dealt with.
func IterativePower(nb int, power int) int {
	// Check for negative power
	if power < 0 {
		return 0
	} else if power == 0 {
		// Base case: power is 0, return 1
		return 1
	}

	// Recursive case: multiply nb by IterativePower with decremented power
	return nb * IterativePower(nb, power-1)
}

func main() {
	// Call IterativePower with nb=4 and power=3 and print the result
	fmt.Println(IterativePower(4, 3)) // Output: 64
}
-----------------------------------------------------------------------------------------------------------------------------
// Exercise 5 - Question 4package main

import (
	"fmt"
)

func Fibonacci(index int) int {
	if index < 0 {
		// A negative index will return -1
		return -1
	} else if index == 0 {
		// The first value at index 0 is 0
		return 0
	} else if index == 1 {
		// The second value at index 1 is 1
		return 1
	} else {
		// Recursive case: Fibonacci value at index is the sum of values at (index-1) and (index-2)
		return Fibonacci(index-1) + Fibonacci(index-2)
	}
}

func main() {
	arg1 := 4
	// Print the Fibonacci value at index 4, which is 3
	fmt.Println(Fibonacci(arg1))
}

