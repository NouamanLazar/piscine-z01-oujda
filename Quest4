// Exercise 1
func IterativeFactorial(nb int) int {
	// If nb is 0, return 1
	if nb == 0 {
		return 1
	} else if nb < 0 || nb > 64 {
		// If nb is negative or greater than 64, return 0
		return 0
	} else {
		// Initialize the result variable to 1
		result := 1
		// Loop to calculate the factorial
		for i := 1; i <= nb; i++ {
			result *= i
		}
		// Return the final result
		return result
	}
}

// Exercise 2
package main

import "fmt"

// RecursiveFactorial is a recursive function that calculates the factorial of the number nb.
// If nb is negative or greater than 64, it returns 0.
func RecursiveFactorial(nb int) int {
	// If nb is 0, return 1
	if nb == 0 {
		return 1
	} else if nb < 0 || nb > 64 {
		// If nb is negative or greater than 64, return 0
		return 0
	} else {
		// Return nb multiplied by RecursiveFactorial with decremented nb
		return nb * RecursiveFactorial(nb-1)
	}
}

func main() {
	arg := -8
	// Call RecursiveFactorial with nb=-8 and print the result
	fmt.Println(RecursiveFactorial(arg))
}

// Exercise 3 - Question 4

// IterativePower is an iterative function that returns the value of nb to the power of power.
// Negative powers will return 0. Overflows do not have to be dealt with.
func IterativePower(nb int, power int) int {
	// Check for negative power
	if power < 0 {
		return 0
	}

	// Initialize the result variable to 1
	result := 1

	// Iterate from 1 to power and multiply nb by itself
	for i := 1; i <= power; i++ {
		result *= nb
	}

	// Return the final result
	return result
}

// Exercise 4 - Question 4
package main

import "fmt"

// IterativePower is a recursive function that calculates the value of nb raised to the power of power.
// If power is negative, the result will be 0. If power is 0, the result will be 1.
// Overflows do not have to be dealt with.
func IterativePower(nb int, power int) int {
	// Check for negative power
	if power < 0 {
		return 0
	} else if power == 0 {
		// Base case: power is 0, return 1
		return 1
	}

	// Recursive case: multiply nb by IterativePower with decremented power
	return nb * IterativePower(nb, power-1)
}

func main() {
	// Call IterativePower with nb=4 and power=3 and print the result
	fmt.Println(IterativePower(4, 3)) // Output: 64
}
